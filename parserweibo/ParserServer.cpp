// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include "MyHeaders.h"
#include "jsongrab5.5.h"
#include "SendJson.h"
#include "MBlogHash.h"
#include "Hbase.h"
#include "MyLog.h"
#include<transport/TSocket.h>
#include <transport/TTransportUtils.h>
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <server/TThreadedServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>


using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace apache::hadoop::hbase::thrift;
using namespace boost;

using namespace sendjson;
using namespace mbloghash;

#define JSONPORT 9085
#define HASHSERVER "192.168.1.184"
#define HASHPORT 9084
#define HBASESERVER "192.168.1.163"
#define HBASEPORT 9090

#define JSONQUEUEMAX 500
#define WEIBOQUEUEMAX 7500
#define HASHSENDTOTAL 500
#define WEIBOLOGITEM 500
#define WEIBOLOGPREFIX "mbloginfo" 
#define WEIBOLOGDIR "/home/mapred/parserlog/"
#define STATELOGITEM 10000
#define STATELOGPREFIX "statelog"
#define STATELOGDIR "/home/mapred/statelog/"
#define QUEUEINFOLOGPREFIX "queueinfo"

pthread_t tid[3];
bool IsExit;

shared_ptr<TTransport> hashsocket(new TSocket(HASHSERVER, HASHPORT));
shared_ptr<TTransport> hashtransport(new TBufferedTransport(hashsocket));
shared_ptr<TProtocol> hashprotocol(new TBinaryProtocol(hashtransport));
MBlogHashClient hashclient(hashprotocol);


shared_ptr<TTransport> hbasesocket(new TSocket(HBASESERVER, HBASEPORT));
shared_ptr<TTransport> hbasetransport(new TBufferedTransport(hbasesocket));
shared_ptr<TProtocol> hbaseprotocol(new TBinaryProtocol(hbasetransport));
HbaseClient hbaseclient(hbaseprotocol);

MyQueue<string>Qjson(JSONQUEUEMAX);
MyQueue<weiboinfo>Qweiboinfo(WEIBOQUEUEMAX);
MyQueue<weibo>Qweibo(WEIBOQUEUEMAX);

interprocess_semaphore jsonsemp(JSONQUEUEMAX);
interprocess_semaphore jsonsemc(0);
interprocess_mutex jsonmutex;

interprocess_semaphore weibosemp(WEIBOQUEUEMAX);
interprocess_semaphore weibosemc(0);
interprocess_mutex weibomutex;

MyLog weibolog(WEIBOLOGITEM, 0);
MyLog statelog(STATELOGITEM, 1);
MyLog queueinfolog(1);

weiboinfo minfohash[HASHSENDTOTAL];
weibo mhash[HASHSENDTOTAL];
vector<string>inmblogid;
vector<string>outmblogid;
vector<string>delfnames;

MYSQL mysql;

void sig_usr(int signo);
void sig_usr2(int signo);

class SendJsonHandler : virtual public SendJsonIf {
 public:
  SendJsonHandler() {
  }

  void SendJsonFileName(const std::vector<std::string> & filename) {
    int i;

    for(i=0; i<filename.size(); i++)
      {
	jsonsemp.wait();
	jsonmutex.lock();
	Qjson.push(filename[i]);
	jsonmutex.unlock();
	jsonsemc.post();
	statelog.write("Client Send Jsonfile %s\n", filename[i].c_str());
	statelog.flush();
      }
  }

  ~SendJsonHandler() {
  }
};

void sig_usr(int signo)
{
  IsExit=1;
  pthread_cancel(tid[0]);
  jsonsemc.post();
  weibosemp.post();
  weibosemc.post();
}

void sig_usr2(int signo)
{
  weibolog.flush();
  statelog.flush();
  queueinfolog.write("JsonQueue size:\t%d\n", Qjson.size());
  queueinfolog.write("WeiboQueue size:\t %d\n", Qweibo.size());
  queueinfolog.flush();
}

void *recvJsonFileNameThread(void *argv)
{
  int port = JSONPORT;
  shared_ptr<SendJsonHandler> handler(new SendJsonHandler());
  shared_ptr<TProcessor> processor(new SendJsonProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  TThreadedServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
}

void *parserThread(void *argv)
{
  string tmpstr;
  int ret;
  
  while(!IsExit)
    {
      jsonsemc.wait();
      if(IsExit)
	break;
      
      tmpstr=Qjson.pop();
      jsonsemp.post();
      
      statelog.write("JsonGrab parser %s Begin\n", tmpstr.c_str());
      statelog.flush();
      ret=jsongrabmysql(tmpstr.c_str());
      if(ret == 1)
	{
	  statelog.write("JsonGrab parser error %s\n", tmpstr.c_str());
	  statelog.flush();
	}
      else 
	{
	  statelog.write("JsonGrab parser successful %s\n", tmpstr.c_str());
	  statelog.flush();
	}
    }
}

int storemblog(weiboinfo& minfo, weibo &mblog)
{
  vector<Mutation>v1, v2;
  Mutation muta;
  char tmpstr[32];
  char mysqlstr[512];

  muta.isDelete=0;

  muta.column="basicinfo:uid";
  sprintf(tmpstr, "%ld", minfo.basicinfo_uid);
  muta.value=tmpstr;
  v1.push_back(muta);

  muta.column="basicinfo:time";
  sprintf(tmpstr, "%ld", minfo.basicinfo_time);
  muta.value=tmpstr;
  v1.push_back(muta);
  
  muta.column="basicinfo:source";
  sprintf(tmpstr, "%ld", minfo.basicinfo_source);
  muta.value=tmpstr;
  v1.push_back(muta);

  muta.column="basicinfo:rtnum";
  sprintf(tmpstr, "%d", minfo.basicinfo_rtnum);
  muta.value=tmpstr;
  v1.push_back(muta);

  muta.column="basicinfo:cmtnum";
  sprintf(tmpstr, "%d", minfo.basicinfo_cmtnum);
  muta.value=tmpstr;
  v1.push_back(muta);

  muta.column="basicinfo:topic";
  muta.value=minfo.basicinfo_topic;
  v1.push_back(muta);

  muta.column="atusers";
  muta.value=minfo.atusers;
  v1.push_back(muta);

  if(minfo.rtinfo_rootid.size() != 0)
    {
      muta.column="rtinfo:rootuid";
      sprintf(tmpstr, "%ld", minfo.rtinfo_rootuid);
      muta.value=tmpstr;
      v1.push_back(muta);

      muta.column="rtinfo:fromuid";
      sprintf(tmpstr, "%ld", minfo.rtinfo_rootuid);
      muta.value=tmpstr;
      v1.push_back(muta);

      muta.column="rtinfo:fromid";
      muta.value=minfo.rtinfo_fromid;
      v1.push_back(muta);

      muta.column="rtinfo:rootid";
      muta.value=minfo.rtinfo_rootid;
      v1.push_back(muta);

      muta.column="rtinfo:rootrtnum";
      sprintf(tmpstr, "%d", minfo.rtinfo_rootrtnum);
      muta.value=tmpstr;
      v1.push_back(muta);
  
      muta.column="rtinfo:rtreason";
      muta.value=minfo.rtinfo_rtreason;
      v1.push_back(muta);
    }

  try
    {
      hbaseclient.mutateRow("weiboinfo", minfo.mblogid, v1);
    }
  catch(IOError &e)
    {
      statelog.write("Hbase RPC Error insert table weiboinfo %s\n", e.what());
      sig_usr(-1);
    }

  muta.column="content";
  muta.value=mblog.content;
  v2.push_back(muta);

  try
    {
      hbaseclient.mutateRow("weibo", minfo.mblogid, v2);
    }
  catch(IOError &e)
    {
      statelog.write("Hbase RPC Error insert table weibo %s\n", e.what());
      sig_usr(-1);
    }

  sprintf(mysqlstr, "insert into weiboNum values(\"%s\", %d, %d, %d, \"%ld\", \"%s\");", minfo.mblogid.c_str(), minfo.basicinfo_rtnum, minfo.basicinfo_cmtnum, minfo.rtinfo_rootrtnum, minfo.basicinfo_time, minfo.basicinfo_topic.c_str());

  if(mysql_query(&mysql, mysqlstr))
    {
      statelog.write("MySQL insert table weiboNum Error %s\n", mysqlstr);
      statelog.flush();
    }

  sprintf(mysqlstr, "insert into weiboUser values(\"%s\", \"%ld\",\"%s\",\"%ld\", \"%s\", \"%ld\", \"%s\");",minfo.mblogid.c_str(), minfo.basicinfo_uid, minfo.rtinfo_fromid.c_str(),minfo.rtinfo_fromuid, minfo.rtinfo_rootid.c_str(), minfo.rtinfo_rootuid, minfo.atusers.c_str());

  if(mysql_query(&mysql, mysqlstr))
    {
      statelog.write("MySQL insert table weiboUser Error %s\n", mysqlstr);
      statelog.flush();
    }

}


void flushWeibo()
{
  int i;
  try
    {
      hashclient.hashBlogId(outmblogid, inmblogid);
    }
  catch(...)
    {
      statelog.write("Hash RPC Error\n");
      sig_usr(-1);
    }

  sort(outmblogid.begin(), outmblogid.end());
  for(i=0; i<inmblogid.size(); i++)
    {
      if(minfohash[i].lastitem)
	{
	  delfnames.push_back(minfohash[i].filename);
	}

      if(binary_search(outmblogid.begin(), outmblogid.end(), inmblogid[i]))
	{
	  weibolog.write("%ld %d %d\n", minfohash[i].basicinfo_uid, minfohash[i].basicinfo_rtnum, minfohash[i].basicinfo_cmtnum);
	  storemblog(minfohash[i], mhash[i]);
	}
    }
  outmblogid.clear();
  inmblogid.clear();

  for(i=0; i<delfnames.size(); i++)
    {
      unlink(delfnames[i].c_str());
      statelog.write("Parser file %s successful\n", delfnames[i].c_str());
      statelog.flush();
    }
  delfnames.clear();
  weibolog.flush();
}



void * insertThread(void *argv)
{
  int i;
  while(!IsExit)
    {
      for(i=0; i < HASHSENDTOTAL;i++)
	{
	  weibosemc.wait();
	  if(IsExit)
	    break;
	  
	  minfohash[i]=Qweiboinfo.pop();
	  mhash[i]=Qweibo.pop();
	  weibosemp.post();

	  inmblogid.push_back(minfohash[i].mblogid);
	}
      statelog.write("Flush Weibo begin\n");
      statelog.flush();
      flushWeibo();
      statelog.write("Flush Weibo over\n");
      statelog.flush();
    }
}

int initVal()
{
  string tmpstr;
  IsExit=0;
  signal(SIGUSR1, sig_usr);  
  signal(SIGUSR2, sig_usr2);  

  if(weibolog.initFile(WEIBOLOGDIR, WEIBOLOGPREFIX))
    {
      printf("weibolog init error\n");
      return -1;
    }
  if(statelog.initFile(STATELOGDIR, STATELOGPREFIX))
    {
      printf("statelog init error\n");
      return -1;
    }
  statelog.write("ParserServer start\n");
  statelog.flush();

  if(queueinfolog.initFile(STATELOGDIR, QUEUEINFOLOGPREFIX))
    {
      printf("queueinfolog init error\n");
      return -1;
    }
  
  hbasetransport->open();
  hashtransport->open();

  mysql_init(&mysql);
  if(!mysql_real_connect(&mysql, "localhost", "chenmin", "chenmin", "sina", 3306, NULL, 0))
    {
      printf("mysql connect error\n");
      return -1;
    }

  return 0;
}

void deinitVal(int fail)
{
  hashtransport->close();
  hbasetransport->close();
  mysql_close(&mysql);
  weibolog.close();
  if(!fail)
    {
      statelog.write("ParserServer stop\n");
    }
  statelog.close();
  queueinfolog.close();
}


int main(int argc, char **argv) {
  int *p;

  if(initVal())
    {
      printf("Init ParserServer Error!\n");	  
      deinitVal(1);
      return 0;
    }

  printf("Parser Server start ...\n");
  pthread_create(&tid[0], NULL, recvJsonFileNameThread, NULL);
  pthread_create(&tid[1], NULL, parserThread, NULL);
  pthread_create(&tid[2], NULL, insertThread, NULL);
  pthread_join(tid[0], (void **)&p);
  pthread_join(tid[1], (void **)&p);
  pthread_join(tid[2], (void **)&p);

  deinitVal(0);
  return 0;
}

